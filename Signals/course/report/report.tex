\documentclass[12pt, a4paper] {ncc}
\usepackage[utf8] {inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian] {babel}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{listings,a4wide,longtable,amsmath,amsfonts,graphicx,tikz}
\usepackage{indentfirst}
\usepackage{bytefield}
\usepackage{multirow}
\usepackage{float}
\usepackage{caption}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{tabularx}

\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}

\newcommand{\cas}{\text{cas}}


\begin{document}
\setcounter{figure}{0}
\frenchspacing
\pagestyle{empty}
\begin{center}
							Университет ИТМО	\\
                        Кафедра вычислительной техники

\vspace{\stretch{2}}
                    Методы цифровой обработки сигналов
\end{center}
\vspace{\stretch{2}}
\begin{center}
                            Курсовая работа по теме:\\
						{\bf <<Исследование влияния конечной разрядности АЛУ спецпроцессора
						 на точность результатов при выполнении линейной фильтрации сигналов>>}
\end{center}
\vspace{\stretch{3}}
\begin{flushright}
                                    Студент:\\
                                    {\it Куклина Мария, P3401}\\
									Преподаватель: \\
									{\it Тропченко А.А.}
\end{flushright}
\vspace{\stretch{4}}
\begin{center}
                             Санкт-Петербург, 2017
\end{center}
\newpage

\section*{Цель работы}

Изучение влияния конечной разрядной сетк специализированного процессора при выполнении
линейной фильтрации на точность формируемого результата.

\section*{Порядок выполнения работы}
	\begin{description}
		\item[Этап 1.] Разработать алгоритм и написать программу, реализующую заданный алгорритм линейной фильтрации,
			  полагая использование форматов чисел с плавающей точкой для исходных данных и получаемых результатов.
		\item[Этап 2.] Разработать алгоритм и написать программу, реализующую тот же алгоритм линейной фильтрации,
			  полагая использование форматов чисел с фиксированой точкой для исходных данных и получаемых результатов.
		\item[Этап 3.] Используя полученные в результате этапа 1 программные средства для получения
			  эталонных результатов:
			\begin{itemize}
				\item построить зависимости среднеквадратичной погрешности от длины N обрабатываемого вектора данных
					  и/или длины ядра преобразования W;
				\item проанализировать влияние на точность формируемого результата способа формирования малоразрядного
					  результата: с отсечением и увеличением младшего разряда на единису, с округлением;
				\item построить зависимости СКО от длины обратаываемого вектора для всех трех
					  указаных способов округления;
				\item построить зависимости СКО от длины обратаываемого вектора при изменении:
				\begin{itemize}
					\item разрядности исеходных данных на 2 и 4 бита при той же разрядности весовых множителей;
					\item разрядности весовых множителей на 2 и 4 бита при неизменной разрядности исходных данных.
				\end{itemize}
			\end{itemize}
	\end{description}
\section*{Вариант}

\textbf{Алгоритм}: быстрое преобразование Хартли; \textbf{N}: $8-1024$; \textbf{n1}: $8$; \textbf{n2}: $8$; \textbf{n3}: $16$.
\section*{Описание работы алгоритма}

Преобразование Хартли основывается на преобразовани Фурье, за тем исключем, что 
в преобразовании Хартли комплексная часть учитывается как действительная.\\

$\cas(\theta) = \sin(\theta) + \cos(\theta)$

$N$-точечное дискретное преобразование Хартли (DHT) имеет вид:\\

$X_h(k) = \sum^{N - 1}_{ n = 0 } x_n \cas(\frac{2 \pi nk} {N})$ \\

Первым шагом разделим $N$-точечную последовательность на две меньших последовательности.
Эти две последовательности имеют преобразование Хартли
соответственно $X_{h1}(k)$ и $X_{h1}(k)$ и комбинируются в $X_h(k)$ выражением: \\


$X_h(k) = \sum^{\frac N 2 - 1}_{n = 0} x_{2n} \cas(\frac{2\pi 2 nk} N) +
 		  \sum^{\frac N 2 - 1}_{n = 0} x_{2n+1} \cas(\frac{2\pi (2n + 1)k} N)$.\\

Вторая часть выражения не является DHT из-з сдвига по времени ($2n + 1$), которое разрешается следующим
способом.\\


$X_h(k + c) = X_h(k)\cos(c) + X_h(k)\sin(c)$, где $c$ -- константа.\\


Тогда мы приходим к следующему выражению. \\


$X_h(k) = X_{h1}(k) + \cos(\frac{2\pi k} N) X_{h2}(k) + \sin(\frac{2\pi k} N) X_{h2}(-k)$ \\

$X_h(-k) = X_h(N - k), - \frac N 2 \leq K < 0$. \\ 


Однако приведённая функция определена на значениях $ 0 \leq k \leq \frac N 2 - 1$. Чтобы вычислять преобразование
на всех $N$ точках преобразуем формулу с учётом свойства периодичности функции $\cas()$. \\

$\cas(\frac{2\pi (n + N)} N) = \cas(\frac{2\pi n} N)$ \\

$\cas(\frac{2\pi (n + \frac{N}{2})} N) = - \cas(\frac{2\pi n} N)$


Тогда формула для всех $k$ обретает вид:\\

$X_h(k) = \begin{cases}
	X_{h1}(k) + \cos(\frac{2\pi k} N) X_{h2}(k) + \sin(\frac{2\pi k} N) X_{h2}(-k) 		 & 0 \leq k \leq \frac N 2 - 1 \\
	X_{h1}(k - \frac{N}{2}) - \cos(\frac{2\pi (k - \frac N 2)} N) X_{h2}(k - \frac N 2)
							- \sin(\frac{2\pi (k - \frac N 2)} N) X_{h2}(-k + \frac N 2) & \frac N 2 \leq k \leq N - 1 \\

\end{cases}
$

\section*{Этап 1}

\lstinputlisting[basicstyle=\scriptsize]{./snippet_fht.rs}

\section*{Этап 2}

\lstinputlisting[basicstyle=\scriptsize]{./snippet_fht_fixed.rs}

\section*{Этап 3}

\begin{figure}[ht!]
    \includegraphics[scale=0.9]{./stdev.png}
    \caption{График зависимости стандартного отклонения от длины вектора}
	\label{fig:vec}
\end{figure}

\begin{figure}[ht!]
    \includegraphics[scale=0.9]{./stdev_i.png}
    \caption{График зависимости стандартного отклонения от длины вектора при ограничении битности входа в 2 и 4 бита}
	\label{fig:input}
\end{figure}

\begin{figure}[ht!]
    \includegraphics[scale=0.9]{./stdev_w.png}
    \caption{График зависимости стандартного отклонения от длины вектора при ограчниее битности весов в 2 и 4 бита}
	\label{fig:weight}
\end{figure}

\section*{Вывод}

В ходе курсовой работы были изучены алгоритмы дискрентного (DHT) и быстрого (FHT)
преобразования Хартли. Было разработано программное обеспечение, производящее вычисление
FHT для чисел с плавающей и фиксированной точкой. 

При анализе зависимости СКО от длины вектора (Рис. \ref{fig:vec}), обнаружилось, что при увеличении длины вектора
увеличивается и отклонение. Это оправдывается ограничением на разрадяность данных и необходимость
округлять данные. Выдающихся отличий методов округления друг от друга выявлено не было.

При анализи зависимотси СКО от длине вектора при ограничении разрядности входного вектора до 2 и 4 бит (Рис. \ref{fig:input})
было выявлено, что большая разрядность даёт меньшее отклонение, однако не существенно меньшее. Обратное
происходит с ограничением разрядность весовых коэффициентов (Рис. \ref{fig:weight}), при которой разряность в
4 бита значительно уменьшает СКО.


\end{document}
